{\rtf1\ansi\ansicpg1252\cocoartf2761
\cocoatextscaling1\cocoaplatform1{\fonttbl\f0\fnil\fcharset0 .SFUI-Regular;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f0\fs24 \cf0 # app.py \'97 webhook app (FastAPI). Minimal evaluate_symbol stub included.\
from fastapi import FastAPI, Request, HTTPException\
import httpx\
import asyncio\
import logging\
import config\
\
app = FastAPI()\
LOG = logging.getLogger("webhook_app")\
logging.basicConfig(level=logging.INFO)\
\
TELEGRAM_API = "https://api.telegram.org"\
\
async def send_telegram_message(chat_id: int, text: str):\
    url = f"\{TELEGRAM_API\}/bot\{config.TELEGRAM_TOKEN\}/sendMessage"\
    payload = \{"chat_id": chat_id, "text": text, "parse_mode": "Markdown"\}\
    async with httpx.AsyncClient(timeout=10.0) as client:\
        r = await client.post(url, json=payload)\
        return r.json()\
\
# Minimal evaluate_symbol stub \'97 replace with your real function later\
def evaluate_symbol(symbol: str):\
    """\
    Return a small structure mimicking the full orchestrator result.\
    This keeps the webhook usable without other modules.\
    """\
    # simple deterministic demo based on symbol hash\
    score = (sum(ord(c) for c in symbol) % 100) / 100.0\
    return \{\
        "symbol": symbol,\
        "hotness": round(score, 3),\
        "strategies": \{"demo": round(min(1.0, score), 3)\},\
        "survivability": \{"1m": round(score, 3), "2m": round(max(0.0, score*0.7), 3), "3m": round(max(0.0, score*0.5), 3)\},\
        "institutional": \{"large_trade_score": 0.1, "orderbook_imb": 0.0\},\
        "alignment": \{"final_pass": score >= 0.8\}\
    \}\
\
@app.post("/webhook/\{token\}")\
async def telegram_webhook(token: str, request: Request):\
    """\
    Telegram will POST updates here. Protect by requiring the token in the path.\
    Usage: set webhook to https://<your-app>/webhook/<YOUR_TOKEN>\
    """\
    if token != config.TELEGRAM_TOKEN:\
        raise HTTPException(status_code=403, detail="Invalid token")\
\
    update = await request.json()\
    msg = update.get("message") or update.get("edited_message") or \{\}\
    text = msg.get("text", "") or ""\
    chat = msg.get("chat", \{\}) or \{\}\
    chat_id = chat.get("id")\
    # simple admin-only /scan command: "/scan SYMBOL"\
    if isinstance(text, str) and text.strip().lower().startswith("/scan"):\
        parts = text.strip().split()\
        if len(parts) < 2:\
            await send_telegram_message(chat_id, "Usage: /scan SYMBOL (admin only)")\
            return \{"ok": True\}\
        if chat_id != config.ADMIN_CHAT_ID:\
            await send_telegram_message(chat_id, "Permission denied. Admins only.")\
            return \{"ok": True\}\
        symbol = parts[1].upper()\
        loop = asyncio.get_event_loop()\
        try:\
            result = await loop.run_in_executor(None, evaluate_symbol, symbol)\
            if result:\
                text_out = f"*\{result['symbol']\}* HOTNESS: *\{result['hotness']\}*\\\\n"\
                surv = result.get("survivability", \{\})\
                text_out += f"Survivability 1M:\{surv.get('1m')\} 2M:\{surv.get('2m')\} 3M:\{surv.get('3m')\}\\\\n"\
                text_out += "Strategies: " + ", ".join([f\\"\{k\}:\{v\}\\" for k,v in result.get('strategies',\{\}).items()])\
            else:\
                text_out = f"No result for \{symbol\}"\
            await send_telegram_message(chat_id, text_out)\
        except Exception as e:\
            LOG.exception("Scan failed")\
            await send_telegram_message(chat_id, f"Scan failed: \{e\}")\
        return \{"ok": True\}\
    return \{"ok": True\}\
\
@app.post("/scan/\{token\}")\
async def http_scan_trigger(token: str, payload: Request):\
    """\
    HTTP trigger: POST /scan/\{token\} with JSON \{"symbol":"BTC/USDT", "reply_to":12345\}\
    """\
    if token != config.TELEGRAM_TOKEN:\
        raise HTTPException(status_code=403, detail="Invalid token")\
    data = await payload.json()\
    symbol = data.get("symbol")\
    reply_to = data.get("reply_to") or config.ADMIN_CHAT_ID\
    if not symbol:\
        raise HTTPException(status_code=400, detail="symbol required")\
    loop = asyncio.get_event_loop()\
    try:\
        result = await loop.run_in_executor(None, evaluate_symbol, symbol.upper())\
        if result:\
            text_out = f"*\{result['symbol']\}* HOTNESS: *\{result['hotness']\}*\\\\n"\
            surv = result.get("survivability", \{\})\
            text_out += f"Survivability 1M:\{surv.get('1m')\} 2M:\{surv.get('2m')\} 3M:\{surv.get('3m')\}\\\\n"\
            text_out += "Strategies: " + ", ".join([f\\"\{k\}:\{v\}\\" for k,v in result.get('strategies',\{\}).items()])\
        else:\
            text_out = f"No result for \{symbol\}"\
        await send_telegram_message(reply_to, text_out)\
        return \{"ok": True, "result": result\}\
    except Exception as e:\
        LOG.exception("Scan error")\
        await send_telegram_message(reply_to, f"Scan failed: \{e\}")\
        raise HTTPException(status_code=500, detail=str(e))\
}